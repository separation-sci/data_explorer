library(dplyr)
library(ggpmisc)
library(tidyverse)
library(colorRamps)

# How to use these functions:
# This file will be used to load any file generated by the 32Karat software (ie. CE files) and to display basic plots.
# When 32Karat files are exported into .asc files, the first 10-20 lines will be meta data.
# Meta data should be loaded first. This will be used to load the raw CE data values.
# 
# Example of how to load a CE file in another file:
# 
# source(".\figure_functions_3.R")
# file_paths = list.files(".",
#                         pattern = ".asc",
#                         full.names = TRUE)
# meta_data = load_meta_ce(file_paths)
# raw_data = load_data_ce(file_paths)

#TODO: Clean repeating code
#TODO: Exporting AU-based data. This NEEDS to be updated. If data is a mix of UV (single column) and LIF, the loading sequence WILL die. PDA only works for 3D pda data!!

#loading files -------------------------------------------------------------------------
#Works for both PDA and LIF/UV formats
load_meta_ce = function(files) {
  df_meta_all = data.frame()
  for (i in files) {
    print(i)
    
    #read in the first 13 lines of the meta file. Do not use read.table because it skips columns even when fill = TRUE.
    #added an encoding conversion for linux ubuntu system. This was not necessary in Windows systems.
    raw_meta = readLines(i, 20) %>%
      iconv(., from = "ISO-8859-1", to = "UTF-8") %>%
      grep("^[A-Za-z]", ., value = TRUE)
    
    values = lapply(raw_meta, function(x)
      str_split(x, "\t")[[1]][-1])
    col_label = lapply(raw_meta, function(x)
      str_split(x, "\t")[[1]][1]) %>%
      unlist()
    col_label = c(col_label, "flnm", "detector")
    
    #loop through each element in the values list and add to the data_meta data frame. Couldn't get a map_df or apply function to work
    df_meta1 = data.frame(V1 = c())
    for (j in values) {
      if (length(j) > 1) {
        df_meta1 = rbind(df_meta1, data.frame(values = I(list(j))))
      } else {
        df_meta1 = rbind(df_meta1, data.frame(values = as.character(j)))
      }
    }
    
    rownames(df_meta1) = NULL
    df_meta1 = df_meta1 %>%
      t() %>%
      as.data.frame() %>%
      mutate(i)
    
    if (ncol(df_meta1) <= 14) {
      detector = "lif_or_uv"
    } else{
      detector = "pda"
    }
    
    df_meta1 = df_meta1 %>%
      mutate(detector)
    
    df_meta_all = rbind(df_meta_all, df_meta1)
  }
  
  rownames(df_meta_all) = NULL
  colnames(df_meta_all) = col_label
  return(df_meta_all)
}

#Works for both PDA and LIF/UV formats
load_data_ce = function(files, data_meta) {
  df_data_all = data.frame()
  for (i in files) {
    print(i)
    
    #find out the line number where the data actually starts
    data_start = ncol(data_meta)
    
    #reading the table as-is. One long column
    data = read.table(file = i,
                      skip = data_start)
    
    #getting the total data points from the meta data (this should be loaded first)
    #TODO: combine the load_meta and load_data functions
    select_meta = data_meta[data_meta$flnm == i,]
    
    if (select_meta$detector == "lif_or_uv") {
      data_time = seq(from = 1,
                      to = as.double(select_meta$`Total Data Points:`[[1]][1])) * as.double(select_meta$`X Axis Multiplier:`[[1]][1]) / as.integer(select_meta$`Sampling Rate:`[[1]][1])
    } else {
      #TODO: figure out the timing for the PDA detector
      data_time = seq(from = 1, to = as.double(select_meta$`Number of Points:`))
    }
    
    #reconstructing the data frame to include a unique id, filename, and all the data split into their appropriate ranges.
    #TODOEDIT: range does not exist.
    
    data_all_fin = data.frame(
      unique_id = str_split(basename(i), ".dat.asc")[[1]][1],
      flnm = i,
      seq = str_replace(dirname(i), "./", ""),
      time = data_time
    )
    
    count = 1
    for (j in seq(from = 0,
                  to = nrow(data),
                  by = length(data_time))) {
      data_all_fin  = cbind(data_all_fin, data[c((j + 1):(j + length(data_time))),])
      if (select_meta$detector == "lif_or_uv") {
        names(data_all_fin)[ncol(data_all_fin)] = select_meta$`Y Axis Title:`$values[count]
      } else{
        names(data_all_fin)[c(5:ncol(data_all_fin))] = paste("abs", seq(from = as.integer(select_meta$`Wavelength Start (nm):`), to = as.integer(select_meta$`Wavelength End (nm):`), by = as.integer(select_meta$`Wavelength Step (nm):`)), sep = "")
      }
      count = count + 1
    }
    
    df_data_all = rbind(df_data_all, data_all_fin)
  }
  rownames(df_data_all) = NULL
  return(df_data_all)
}

# plots -------------------------------------------------------------------
plot_report_ce = function(data, offset){
  if(length(unique(data$unique_id)) != length(offset)){
    stop("number of offset values does not match number of traces")
  }
  
  plot = ggplot()
  trace_names = unique(data$unique_id)
  
  #match the offset values to each trace name just by default order. If plot needs to be re-ordered, that will be done prior to this function.
  #TODO: make a new function for re-ordering the plots
  offset_col = setNames(offset, trace_names)
  data$offset = offset_col[data$unique_id]
  
  #TODO this may need to be modified to accommodate PDA detectors
  y_axis_unit = grep("rfu|au", colnames(data), ignore.case = TRUE)
  
  data_offset = data
  data_offset[,y_axis_unit] = data_offset[,y_axis_unit] + data_offset[,ncol(data)]
  
  plot = plot + 
    geom_path(data_offset, mapping = aes_string(x = "time", y = colnames(data)[y_axis_unit], color = "unique_id")) +
    theme(
      panel.background = element_blank(),
      axis.line = element_line(colour = "black"),
      legend.position = "bottom",
      legend.title = element_blank()
    )
  
  return(plot)
}

flatten_row <- function(row) {
  if (length(row[!is.na(row)]) > 1) {
    return(row[!is.na(row)])
  } else {
    return(row[1])
  }
}
